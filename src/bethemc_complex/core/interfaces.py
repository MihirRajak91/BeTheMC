"""
🔌 Core Interfaces for BeTheMC Complex Architecture

This module defines the core interfaces and protocols that establish the contract
between different components of the complex architecture. These interfaces ensure
type safety, loose coupling, and clear separation of concerns across the system.

Key Features:
- Protocol-based interfaces for runtime type checking
- Dataclass definitions for core data structures
- Abstract interfaces for major system components
- Type-safe contracts between layers

Architecture:
- Uses Python's Protocol class for structural typing
- Dataclasses for immutable data structures
- Clear separation between data models and behavior contracts
- Supports dependency injection and testing

Usage:
    from bethemc_complex.core.interfaces import (
        PersonalityTraits, Choice, StoryGenerator, GameState
    )
    
    # Use data structures
    traits = PersonalityTraits(friendship=0.7, courage=0.8, ...)
    choice = Choice(text="Help the Pokémon", effects={"friendship": 0.1})
    
    # Implement interfaces
    class MyStoryGenerator:
        def generate_narrative(self, location, personality, ...):
            # Implementation here
            pass
"""
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Protocol
from dataclasses import dataclass
from datetime import datetime

@dataclass
class PersonalityTraits:
    """
    🧠 Player Personality Traits Data Structure
    
    Represents the player's personality characteristics that influence story
    generation and choice outcomes. Each trait is a float between 0.0 and 1.0,
    where higher values indicate stronger manifestation of that trait.
    
    Traits:
        - friendship: How well the player gets along with others (0.0-1.0)
        - courage: How brave the player is in dangerous situations (0.0-1.0)
        - curiosity: How much the player explores and investigates (0.0-1.0)
        - wisdom: How thoughtful and strategic the player is (0.0-1.0)
        - determination: How persistent the player is in achieving goals (0.0-1.0)
    
    Example:
        traits = PersonalityTraits(
            friendship=0.7,    # Very friendly
            courage=0.8,        # Very brave
            curiosity=0.6,      # Moderately curious
            wisdom=0.5,         # Balanced wisdom
            determination=0.9   # Very determined
        )
    """
    friendship: float
    courage: float
    curiosity: float
    wisdom: float
    determination: float

@dataclass
class Choice:
    """
    ⚡ Player Choice Data Structure
    
    Represents a choice option presented to the player during gameplay.
    Each choice has descriptive text and effects that modify the player's
    personality traits when selected.
    
    Attributes:
        text: The choice text displayed to the player
        effects: Dictionary mapping personality traits to effect values
                Positive values increase traits, negative values decrease them
    
    Example:
        choice = Choice(
            text="Help the injured Pokémon",
            effects={"friendship": 0.1, "courage": 0.05}
        )
        
        choice2 = Choice(
            text="Walk away and ignore it",
            effects={"friendship": -0.1, "courage": -0.05}
        )
    """
    text: str
    effects: Dict[str, float]

@dataclass
class NarrativeSegment:
    """
    📖 Story Narrative Segment Data Structure
    
    Represents a segment of the story narrative generated by the story system.
    Each segment contains the story content, location context, timestamp,
    and additional context for the story generation system.
    
    Attributes:
        content: The story text content to display to the player
        location: Where this narrative segment takes place
        timestamp: When this narrative was generated
        context: Additional context data for story generation
    
    Example:
        segment = NarrativeSegment(
            content="You step into Professor Oak's bustling laboratory...",
            location="Oak's Laboratory",
            timestamp=datetime.utcnow(),
            context={"npc_present": "Professor Oak", "time_of_day": "morning"}
        )
    """
    content: str
    location: str
    timestamp: datetime
    context: Dict[str, Any]

@dataclass
class Memory:
    """
    🧠 Player Memory Data Structure
    
    Represents a memory or experience that the player has collected during
    their adventure. Memories influence story generation and provide context
    for future narrative decisions.
    
    Attributes:
        memory_type: Type of memory (promise, friendship, event, location, achievement)
        content: Description of the memory
        location: Where this memory was formed
        timestamp: When this memory was created
        metadata: Additional data about the memory
    
    Memory Types:
        - promise: Commitments made to characters
        - friendship: Relationship developments
        - event: Significant story events
        - location: Place-specific memories
        - achievement: Accomplishments and milestones
    
    Example:
        memory = Memory(
            memory_type="promise",
            content="I promised to become a Pokémon Master",
            location="Oak's Laboratory",
            timestamp=datetime.utcnow(),
            metadata={"character": "Professor Oak", "importance": "high"}
        )
    """
    memory_type: str
    content: str
    location: str
    timestamp: datetime
    metadata: Dict[str, Any]

class StoryGenerator(Protocol):
    """
    📚 Story Generation Interface Protocol
    
    Defines the contract for story generation components in the complex architecture.
    Implementations of this protocol are responsible for creating narrative content
    and choice options based on the current game state and context.
    
    This protocol enables:
    - Multiple story generation strategies (AI-based, rule-based, etc.)
    - Easy testing with mock implementations
    - Loose coupling between story logic and game state
    - Runtime type checking for story generators
    
    Example Implementation:
        class AIStoryGenerator:
            def generate_narrative(self, location, personality, recent_events, context):
                # AI-based story generation logic
                return NarrativeSegment(...)
            
            def generate_choices(self, situation, personality, context):
                # AI-based choice generation logic
                return [Choice(...), Choice(...)]
    """
    
    def generate_narrative(self, 
                          location: str,
                          personality: PersonalityTraits,
                          recent_events: List[str],
                          context: Dict[str, Any]) -> NarrativeSegment:
        """
        📖 Generate Narrative Segment
        
        Creates a narrative segment based on the current game state and context.
        This method should produce coherent, contextually appropriate story content
        that reflects the player's personality and recent events.
        
        Args:
            location: Current location in the game world
            personality: Player's current personality traits
            recent_events: List of recent events for context
            context: Additional context data for story generation
        
        Returns:
            NarrativeSegment: Generated story content with metadata
        
        Example:
            segment = story_generator.generate_narrative(
                location="Oak's Laboratory",
                personality=PersonalityTraits(friendship=0.7, courage=0.8, ...),
                recent_events=["Met Professor Oak", "Chose Charmander"],
                context={"time_of_day": "morning", "weather": "sunny"}
            )
        """
        ...
    
    def generate_choices(self,
                        situation: str,
                        personality: PersonalityTraits,
                        context: Dict[str, Any]) -> List[Choice]:
        """
        ⚡ Generate Choice Options
        
        Creates a list of choice options appropriate for the current situation.
        Choices should reflect the player's personality and provide meaningful
        consequences that affect the story progression.
        
        Args:
            situation: Description of the current situation
            personality: Player's current personality traits
            context: Additional context data for choice generation
        
        Returns:
            List[Choice]: Available choice options for the player
        
        Example:
            choices = story_generator.generate_choices(
                situation="A wild Pokémon appears injured",
                personality=PersonalityTraits(friendship=0.7, courage=0.8, ...),
                context={"pokemon_type": "fire", "location": "forest"}
            )
        """
        ...

class KnowledgeBase(Protocol):
    """
    🧠 Knowledge Storage and Retrieval Interface Protocol
    
    Defines the contract for knowledge base components that store and retrieve
    player memories, location information, and other contextual data needed
    for story generation and game progression.
    
    This protocol enables:
    - Multiple storage backends (database, file system, memory)
    - Efficient memory retrieval and search
    - Context-aware information access
    - Scalable knowledge management
    
    Example Implementation:
        class DatabaseKnowledgeBase:
            def add_memory(self, memory):
                # Store memory in database
                pass
            
            def get_memories_by_type(self, memory_type, limit):
                # Retrieve memories from database
                return [Memory(...), Memory(...)]
    """
    
    def add_memory(self, memory: Memory) -> str:
        """
        💾 Add Memory to Knowledge Base
        
        Stores a new memory in the knowledge base for future retrieval.
        The memory will be used to provide context for story generation
        and influence narrative decisions.
        
        Args:
            memory: Memory object to store
        
        Returns:
            str: Unique identifier for the stored memory
        
        Example:
            memory_id = knowledge_base.add_memory(
                Memory(
                    memory_type="promise",
                    content="I promised to become a Pokémon Master",
                    location="Oak's Laboratory",
                    timestamp=datetime.utcnow(),
                    metadata={"character": "Professor Oak"}
                )
            )
        """
        ...
    
    def get_memories_by_type(self, memory_type: str, limit: int = 10) -> List[Memory]:
        """
        🔍 Retrieve Memories by Type
        
        Retrieves memories of a specific type from the knowledge base.
        This is useful for finding related memories that can influence
        story generation and character interactions.
        
        Args:
            memory_type: Type of memories to retrieve
                        (promise, friendship, event, location, achievement)
            limit: Maximum number of memories to return
        
        Returns:
            List[Memory]: List of memories matching the criteria
        
        Example:
            promises = knowledge_base.get_memories_by_type("promise", limit=5)
            friendships = knowledge_base.get_memories_by_type("friendship", limit=10)
        """
        ...
    
    def get_relevant_memories(self, query: str, limit: int = 5) -> List[Memory]:
        """
        🔍 Search for Relevant Memories
        
        Performs semantic search to find memories relevant to a given query.
        This enables context-aware story generation by finding memories
        that relate to the current situation or topic.
        
        Args:
            query: Search query to find relevant memories
            limit: Maximum number of memories to return
        
        Returns:
            List[Memory]: List of memories relevant to the query
        
        Example:
            relevant = knowledge_base.get_relevant_memories(
                "Professor Oak laboratory", limit=3
            )
        """
        ...
    
    def get_location_info(self, location: str) -> Dict[str, Any]:
        """
        📍 Get Location Information
        
        Retrieves information about a specific location in the game world.
        This information can include NPCs, landmarks, events, and other
        contextual data that influences story generation.
        
        Args:
            location: Name of the location to get information about
        
        Returns:
            Dict[str, Any]: Location information and metadata
        
        Example:
            oak_lab_info = knowledge_base.get_location_info("Oak's Laboratory")
            # Returns: {
            #     "npcs": ["Professor Oak", "Assistant"],
            #     "landmarks": ["Pokéball machine", "Research desk"],
            #     "events": ["Starter selection", "Pokédex delivery"],
            #     "description": "A bustling research laboratory..."
            # }
        """
        ...

class ProgressionTracker(Protocol):
    """
    📈 Story Progression Tracking Interface Protocol
    
    Defines the contract for components that track and manage story progression.
    This includes scene history, compressed context generation, and story
    context management for the complex narrative system.
    
    This protocol enables:
    - Multiple progression tracking strategies
    - Context compression for long stories
    - Scene history management
    - Story continuity maintenance
    
    Example Implementation:
        class SceneProgressionTracker:
            def add_scene(self, scene):
                # Add scene to history
                pass
            
            def get_compressed_context(self, location):
                # Generate compressed context
                return {"summary": "...", "key_points": [...]}
    """
    
    def add_scene(self, scene: Dict[str, Any]) -> None:
        """
        📝 Add Scene to Progression History
        
        Records a new scene in the progression history. Scenes represent
        significant story moments that contribute to the overall narrative
        and provide context for future story generation.
        
        Args:
            scene: Scene data including content, location, characters, etc.
        
        Example:
            progression_tracker.add_scene({
                "content": "You meet Professor Oak in his laboratory",
                "location": "Oak's Laboratory",
                "characters": ["Professor Oak"],
                "choices_made": ["Chose Charmander"],
                "timestamp": datetime.utcnow()
            })
        """
        ...
    
    def get_compressed_context(self, location: str) -> Dict[str, Any]:
        """
        📦 Get Compressed Context for Location
        
        Generates a compressed summary of relevant story context for a
        specific location. This helps maintain story continuity while
        managing memory usage for long-running stories.
        
        Args:
            location: Location to generate context for
        
        Returns:
            Dict[str, Any]: Compressed context including summary, key points,
                           active promises, and relationships
        
        Example:
            context = progression_tracker.get_compressed_context("Viridian City")
            # Returns: {
            #     "compressed_summary": "Recent: Pallet Town → Oak's Lab → Viridian City",
            #     "active_promises": ["Become Pokémon Master", "Help Professor Oak"],
            #     "key_relationships": ["Professor Oak: mentor", "Mom: family"],
            #     "location_context": ["First time in Viridian City"],
            #     "story_length": 15
            # }
        """
        ...
    
    def get_story_context(self) -> Dict[str, Any]:
        """
        📖 Get Current Story Context
        
        Retrieves the complete current story context including recent scenes,
        memories organized by type, and overall story statistics.
        
        Returns:
            Dict[str, Any]: Complete story context with scenes, memories, and stats
        
        Example:
            context = progression_tracker.get_story_context()
            # Returns: {
            #     "recent_scenes": [scene1, scene2, scene3, ...],
            #     "memories": {
            #         "promises": ["Become Pokémon Master", "Help Professor Oak"],
            #         "friendships": ["Professor Oak: mentor", "Mom: family"],
            #         "events": ["Chose Charmander", "Won first battle"]
            #     },
            #     "total_scenes": 25,
            #     "total_memories": 12
            # }
        """
        ...

class GameState(Protocol):
    """
    🎮 Game State Interface Protocol
    
    Defines the contract for game state management components. This protocol
    ensures that all game state implementations provide consistent access
    to player state, personality, events, and state modification methods.
    
    This protocol enables:
    - Multiple game state implementations
    - Consistent state access patterns
    - Type-safe state modifications
    - Easy testing and mocking
    
    Example Implementation:
        class DatabaseGameState:
            @property
            def location(self):
                return self._load_location_from_db()
            
            def update_personality(self, effects):
                # Update personality in database
                pass
    """
    
    @property
    def location(self) -> str:
        """
        📍 Current Location Property
        
        Returns the player's current location in the game world.
        
        Returns:
            str: Current location name
        
        Example:
            current_location = game_state.location  # "Viridian City"
        """
        ...
    
    @property
    def personality(self) -> PersonalityTraits:
        """
        🧠 Current Personality Property
        
        Returns the player's current personality traits.
        
        Returns:
            PersonalityTraits: Current personality state
        
        Example:
            traits = game_state.personality
            print(f"Friendship: {traits.friendship}, Courage: {traits.courage}")
        """
        ...
    
    @property
    def recent_events(self) -> List[str]:
        """
        📝 Recent Events Property
        
        Returns the list of recent events that have occurred.
        
        Returns:
            List[str]: Recent events in chronological order
        
        Example:
            events = game_state.recent_events
            # ["Met Professor Oak", "Chose Charmander", "Won first battle"]
        """
        ...
    
    def update_personality(self, effects: Dict[str, float]) -> None:
        """
        🔄 Update Personality Traits
        
        Modifies the player's personality traits based on the provided effects.
        
        Args:
            effects: Dictionary mapping trait names to effect values
                    Positive values increase traits, negative values decrease them
        
        Example:
            game_state.update_personality({
                "courage": 0.1,
                "friendship": 0.05,
                "wisdom": -0.02
            })
        """
        ...
    
    def add_event(self, event: str) -> None:
        """
        📝 Add Event to History
        
        Adds a new event to the player's recent event history.
        
        Args:
            event: Description of the event that occurred
        
        Example:
            game_state.add_event("Won the Viridian City Gym battle")
        """
        ...

class SaveManager(Protocol):
    """
    💾 Save/Load Operations Interface Protocol
    
    Defines the contract for save and load operations in the game system.
    This protocol ensures consistent save/load behavior across different
    storage backends and provides type-safe save management.
    
    This protocol enables:
    - Multiple storage backends (database, file system, cloud)
    - Consistent save/load patterns
    - Save file management operations
    - Type-safe save operations
    
    Example Implementation:
        class DatabaseSaveManager:
            def save_game(self, session_id, save_name, data):
                # Save to database
                return True
            
            def load_game(self, save_name):
                # Load from database
                return game_data
    """
    
    def save_game(self, session_id: str, save_name: str, data: Dict[str, Any]) -> bool:
        """
        💾 Save Game Data
        
        Saves the current game state with a specified name for later loading.
        
        Args:
            session_id: Unique session identifier
            save_name: User-friendly name for the save file
            data: Game state data to save
        
        Returns:
            bool: True if save was successful, False otherwise
        
        Example:
            success = save_manager.save_game(
                session_id="player-123",
                save_name="Before Gym Battle",
                data={"location": "Viridian City", "personality": {...}}
            )
        """
        ...
    
    def load_game(self, save_name: str) -> Optional[Dict[str, Any]]:
        """
        📂 Load Game Data
        
        Loads a previously saved game state by name.
        
        Args:
            save_name: Name of the save file to load
        
        Returns:
            Optional[Dict[str, Any]]: Loaded game data or None if not found
        
        Example:
            game_data = save_manager.load_game("Before Gym Battle")
            if game_data:
                # Restore game state
                pass
        """
        ...
    
    def list_saves(self) -> List[str]:
        """
        📁 List Available Saves
        
        Returns a list of all available save file names.
        
        Returns:
            List[str]: List of save file names
        
        Example:
            saves = save_manager.list_saves()
            # ["Before Gym Battle", "After First Victory", "Pallet Town Start"]
        """
        ...
    
    def delete_save(self, save_name: str) -> bool:
        """
        🗑️ Delete Save File
        
        Deletes a save file by name.
        
        Args:
            save_name: Name of the save file to delete
        
        Returns:
            bool: True if deletion was successful, False otherwise
        
        Example:
            success = save_manager.delete_save("Old Save")
        """
        ...

class ConfigProvider(Protocol):
    """
    ⚙️ Configuration Management Interface Protocol
    
    Defines the contract for configuration management components. This protocol
    ensures consistent access to configuration values across the system.
    
    This protocol enables:
    - Multiple configuration sources (file, environment, database)
    - Type-safe configuration access
    - Default value handling
    - Configuration validation
    
    Example Implementation:
        class FileConfigProvider:
            def get(self, key, default=None):
                # Read from configuration file
                return config_value
            
            def get_all(self):
                # Return all configuration
                return all_config
    """
    
    def get(self, key: str, default: Any = None) -> Any:
        """
        🔧 Get Configuration Value
        
        Retrieves a configuration value by key with optional default.
        
        Args:
            key: Configuration key to retrieve
            default: Default value if key is not found
        
        Returns:
            Any: Configuration value or default
        
        Example:
            db_url = config_provider.get("DATABASE_URL", "mongodb://localhost")
            max_players = config_provider.get("MAX_PLAYERS", 100)
        """
        ...
    
    def get_all(self) -> Dict[str, Any]:
        """
        📋 Get All Configuration
        
        Returns all configuration values as a dictionary.
        
        Returns:
            Dict[str, Any]: All configuration key-value pairs
        
        Example:
            all_config = config_provider.get_all()
            # {
            #     "DATABASE_URL": "mongodb://localhost",
            #     "MAX_PLAYERS": 100,
            #     "DEBUG": True,
            #     "API_VERSION": "v1"
            # }
        """
        ... 